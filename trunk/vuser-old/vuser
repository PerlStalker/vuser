#!/usr/bin/perl -w
use strict;

# $Id: vuser,v 1.7 2004-06-08 22:33:00 stewatvireo Exp $

#
# Configuration
#
use Config::IniFiles;
use Getopt::Long;
use FindBin qw($Bin);

# Command line options.
my $config_file;

Getopt::Long::Configure('require_order', 'pass_through');
GetOptions("config|f=s", \$config_file);

if (not $config_file) {
    for my $cfile ('/usr/local/etc/vuser.conf',
		   '/etc/vuser.conf',
		   "$Bin/../etc/vuser.conf",
		   "$Bin/vuser.conf"
		   )
    {
	if (-e $cfile) {
	    $config_file = $cfile;
	    last;
	}
    }
}

# Setup Config file.
my %cfg;
tie %cfg, 'Config::IniFiles', ( -file => $config_file );

my $hosteddomains = $cfg{courier}{etc}."/hosteddomains";
my $esmtpacceptmailfor = $cfg{courier}{etc}."/esmtpacceptmailfor";
my $logindomainlist = $cfg{courier}{etc}."/logindomainlist";

my $makehosteddomains = $cfg{courier}{sbin}."/makehosteddomains";
my $makeacceptmailfor = $cfg{courier}{sbin}."/makeacceptmailfor";
my $courier_rc = $cfg{courier}{courier_rc};

if( 0+$cfg{courier_mysql}{use_authmysql} )
{
    print "You are here ($cfg{courier_mysql}{use_authmysql})\n";
    my $authmysqlrc = $cfg{courier}{etc} . "/authmysqlrc";
    open (AUTHMYSQL, $authmysqlrc ) 
	or die "Can't open $authmysqlrc.: $!\n";

    while (my $line = <AUTHMYSQL>)
    {
	chomp $line;
	# Skip comments and blank lines.
	next if ($line =~ /^\s*\#/ or $line =~ /^\s*$/ );
	$line =~ s/\s*$//;              # Strip extra ws from the end
	if ($line =~ /^\s*MYSQL_(\w+)   # Get MYSQL_XXX. XXX -> $1
	    \s+(.+)$/x)                 # Get value. -> $2
	{
	    if( ! $cfg{courier_mysql}{$1} )
	    {
	    	$cfg{courier_mysql}{$1} = $2;
	    }
	}
    }
    
    close AUTHMYSQL;

}


#
# SpamAssassin
#
if ($cfg{spamassassin}{use_sa} )	# If we're using SpamAssassin
{
    # Read SA conf file
    my $sa_conf = $cfg{spamassassin}{sa_conf};
    open (SA, $sa_conf) or die "Can't open $sa_conf: $1\n";
    while (my $line = <SA>)
    {
	chomp $line;
	next if ($line =~ /^\s*#/	# Skip comments ...
		 or $line =~ /^\s*$/);	# ... and blank lines
	$line =~ s/\s*$//;		# Strip extra ws from the end
	if ($line =~ /^\s*user_scores_(\w+)	# Get user_scores_* variables -> $1
                      \s+(.+)/x)		# and values -> $2
	{
	    $cfg{spamassassin}{$1} = $2;
	}
    }
    close SA;
}

#
# SquirrelMail
#
if( $cfg{sm}{sm_config} &&
    ( $cfg{sm}{use_sm_address} ||
      $cfg{sm}{use_sm_userpref} ))
{
    # Read SquirrelMail conf file
    my $sm_config = $cfg{sm}{sm_config};
    open (SM, $sm_config)
	or die "Can't open SquirrelMail config '$sm_config': $!\n";

    while (my $line = <SM>)
    {
	chomp $line;
	if ($line =~ /^\s*\$addrbook_dsn\s*=\s*'(.*)';/)
	{
	    my $dsn = $1;
	    my ($type, $user, $pass, $host, $db) =
		$dsn =~ m|^(.*?)://(.*?):(.*?)\@(.*?)/(.*)$|;
	    $cfg{sm}{address_dsn} = "DBI:$type:$db:$host";
	    $cfg{sm}{address_username} = $user;
	    $cfg{sm}{address_password} = $user;
	}
	elsif ($line =~ /^\s*\$addrbook_table\s*=\s*'(.*)';$/)
	{
	    $cfg{sm}{address_table} = $1;
	}
	elsif ($line =~ /^\s*\$prefs_dsn\s*=\s*'(.*)';*/)
	{
	    my $dsn = $1;
	    my ( $type, $user, $pass, $host, $db ) =
		$dsn =~ m|^(.*?)://(.*?):(.*?)\@(.*?)/(.*)$|;
	    $cfg{sm}{userpref_dsn} = "DBI:$type:$db:$host";
	    $cfg{sm}{userpref_type} = $type;
	    $cfg{sm}{userpref_user} = $user;
	    $cfg{sm}{userpref_pass} = $pass; 
	    $cfg{sm}{userpref_host} = $host;
	    $cfg{sm}{userpref_db}= $db;

	}
	elsif ($line =~ /^\s*\$prefs_table\s*=\s*'(.*)';$/)
	{
	    $cfg{sm}{userpref_table} = $1;	    
	}
	elsif ($line =~ /^\s*\$prefs_user_field\s*=\s*'(.*)';$/)
	{
	    $cfg{sm}{userpref_user_field} = $1;	    
	}
	elsif ($line =~ /^\s*\$prefs_key_field\s*=\s*'(.*)';$/)
	{
	    $cfg{sm}{userpref_key_field} = $1;	    
	}
	elsif ($line =~ /^\s*\$prefs_val_field\s*=\s*'(.*)';$/)
	{
	    $cfg{sm}{userpref_val_field} = $1;	    
	}
    }
    close SM;
    #use Data::Dumper; print Dumper %sm_address_conf;
    #use Data::Dumper; print Dumper %sm_userpref_conf;
}

#
# Connect to courier accounts DB

use DBI;
my $cdb = DBI->connect( "DBI:mysql:" . 
			$cfg{courier_mysql}{DATABASE} . ":" . 
			$cfg{courier_mysql}{SERVER} . ":" . 
			$cfg{courier_mysql}{PORT}, 
			$cfg{courier_mysql}{USERNAME},
			$cfg{courier_mysql}{PASSWORD} );
			 
#print( "\n\nmy $cdb = DBI->connect( DBI:mysql: . $cfg{courier_mysql}{SERVER} . : . $cfg{courier_mysql}{PORT}, $cfg{courier_mysql}{USERNAME}, $cfg{courier_mysql}{PASSWORD} );\n\n\n" );
			 
die "Can't connect to Courier DB: $DBI::errstr\n" unless $cdb;
$cdb->do("use $cfg{courier_mysql}{DATABASE}");

#
# Connect to SapmAssassin DB
my $sadb;
if ( $cfg{spamassassin}{use_sa} )
{
    $sadb = DBI->connect ( "DBI:mysql:".
			   $cfg{spamassassin}{sql_database} . ":" .
			   $cfg{spamassassin}{sql_server} . ":" .
			   $cfg{spamassassin}{sql_port},
			   $cfg{spamassassin}{sql_username},
			   $cfg{spamassassin}{sql_password} );

    die "Can't connect to SpamAssassin DB: $DBI::errstr\n" unless $sadb;

    $sadb->do("use $cfg{spamassassin}{sql_database}");
}

#
# Connect to SquirrelMail accounts DB
my $sm_addr_db;
if( $cfg{sm}{use_sm_address} )
{
    # Connect to SM address DB
    $sm_addr_db = DBI->connect ($cfg{sm}{address_dsn},
				$cfg{sm}{address_username},
				$cfg{sm}{address_password} );

    die "Can't connect to SquirrelMail (Address) DB: $DBI::errstr\n" unless $sm_addr_db;
}

#
# Connect to SquirrelMail userpref DB, if needed.
my $sm_pref_db;
if( $cfg{sm}{use_sm_userpref} )
{
    $sm_pref_db = DBI->connect ($cfg{sm}{userpref_dsn},
				$cfg{sm}{userpref_username},
				$cfg{sm}{userpref_password} );
    die "Can't connect to SquirrelMail (Userpref) DB: $DBI::errstr\n" unless $sm_pref_db;
}

#
# Ok. All the setup work has been done. Let's do some real work.
#
sub get_home_directory
{
    my ($user, $domain) = @_;

    return eval( $cfg{courier}{userhomedir} );
}
sub get_domain_directory
{
    my ($domain) = @_;

    return eval( $cfg{courier}{domaindir} );
}

if (@ARGV < 2) { help(); exit 0 };

my $cmd = shift @ARGV;
$cmd = lc $cmd;

if    ($cmd eq 'add')	{ add(@ARGV); }
elsif ($cmd eq 'del')	{ del(@ARGV); }
elsif ($cmd eq 'mod')	{ mod(@ARGV); }
elsif ($cmd eq 'show')	{ show(@ARGV); }
elsif ($cmd eq 'alias')	{ alias(@ARGV); }
elsif ($cmd eq 'domain'){ domain(@ARGV); }
elsif ($cmd eq 'list')	{ list(@ARGV); }
elsif ($cmd eq 'help'
       or $cmd eq '-h')	{ help(@ARGV); }
else			{ help(); }

exit 0;

sub add
{
    my ($account, @params) = @_;
    die "No account specified\n" if not $account;

    my ($user, $domain) = $account =~ m/^(\S+?)\@(\S+)$/;
    $domain = 'default' if not $domain;
    $domain = lc($domain);

    # Get other params.
    my $name = '';
    my $password = '';
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-n') { $name = $params[$i+1]; }
	elsif ($params[$i] eq '-p') { $password = $params[$i+1]; }
    }
    $password = generate_password(10) if (not $password);


    my $userdir = get_home_directory( $user, $domain );
    die "Can't add account: User exists\n" if (-e "$userdir");
    die "Can't add account: Skel doesn't exist\n" if( !( -e "$cfg{courier}{skeldir}" ) );
    if( not -e "$userdir" )
    {
	mkdir_p( "$userdir", 
		 0775, 
		 (getpwnam($cfg{courier}{courier_user}))[2],  		
		 (getgrnam($cfg{courier}{courier_group}))[2] )
	    || die "could not create user directory: $userdir";
    }

    my $rc = 0xffff & system ('cp', '-R', $cfg{courier}{skeldir}, "$userdir");
    $rc <<= 8;
    die "Can't copy skel dir $cfg{courier}{skeldir} to $userdir: $!\n"
	if $rc != 0;
    system('chown', '-R', "$cfg{courier}{courier_user}:$cfg{courier}{courier_group}", "$userdir");

    # Add the user to MySQL
    my $sql = "INSERT into $cfg{courier_mysql}{USER_TABLE} set ";
    $sql .= " $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account);
    $sql .= ", $cfg{courier_mysql}{UID_FIELD} = ".$cdb->quote((getpwnam($cfg{courier}{courier_user}))[2]);
    $sql .= ", $cfg{courier_mysql}{GID_FIELD} = ".$cdb->quote((getgrnam($cfg{courier}{courier_group}))[2]);
    $sql .= ", $cfg{courier_mysql}{CRYPT_PWFIELD} = ".$cdb->quote(crypt($password, $password)) if $cfg{courier_mysql}{CRYPT_PWFIELD};
    $sql .= ", $cfg{courier_mysql}{CLEAR_PWFIELD} = ".$cdb->quote($password) if $cfg{courier_mysql}{CLEAR_PWFIELD};
    $sql .= ", $cfg{courier_mysql}{HOME_FIELD} = ".$cdb->quote("$userdir");
    $sql .= ", $cfg{courier_mysql}{NAME_FIELD} = ".$cdb->quote($name);
    $sql .= ", $cfg{courier_mysql}{QUOTA_FIELD} = ".$cdb->quote($cfg{courier}{quota});
    $sql .= ";";

    $cdb->do($sql) or die "Can't add account: ".$cdb->errstr()."\n";
}


sub del
{
    my ($account, @params) = @_;
    die "No account specified\n" if not $account;

    my ($user, $domain) = $account =~ m/^(\S+?)\@(\S+)$/;
    my $userdir = get_home_directory( $user, $domain );

#     $domain = 'default' if not $domain;
#     $domain = lc($domain);
#     my $XY = substr($user, 0, 2);	# Get the first 2 chars of $user

    # delete aliases first
    alias_del($account);

    system ('rm', '-r', "$userdir");

    my $sql = "DELETE from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account).";";
    $cdb->do($sql) or die "Can't delete account: ".$cdb->errstr()."\n";

    # If we're using SpamAssassin, we're going to have to clean out those prefs as well.
    if ($cfg{spamassassin}{use_sa})
    {
	my $sql = "DELETE from $cfg{spamassassin}{sql_table} where username = ".$sadb->quote($account).";";
	$sadb->do($sql) or die "Can't delete account SpamAssassin preferences: ".$sadb->errstr()."\n";
    }

    # Delete SquirrelMail address book, if used
    if ($cfg{sm}{use_sm_address})
    {
	my $sql = "DELETE from $cfg{sm}{address_table} where owner = ".$sm_addr_db->quote($account).";";
	$sm_addr_db->do($sql) or die "Can't delete account SquirrelMail address book: ".$sm_addr_db->errstr()."\n";
    }

    # Delete SquirrelMail preferences, if used
    if ($cfg{sm}{use_sm_userpref})
    {
	my $sql = "DELETE from $cfg{sm}{userpref_table} where $cfg{sm}{userpref_user_field} = ".$sm_pref_db->quote($account).";";
	$sm_pref_db->do($sql) or die "Can't delete account SquirrelMail preferences: ".$sm_pref_db->errstr()."\n";
    }
}

sub mod
{
    my ($account, @params) = @_;
    die "No account specified\n" if not $account;

    my ($user, $domain) = $account =~ m/^(\S+?)\@(\S+)$/;
    $domain = 'default' if not $domain;
    $domain = lc($domain);

    # Get other params.
    my $name = '';
    my $password = '';
    my $new_acct = '';
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-n') { $name = $params[$i+1]; }
	elsif ($params[$i] eq '-p') { $password = $params[$i+1]; }
	elsif ($params[$i] eq '-a') { $new_acct = $params[$i+1]; }
    }

    my ($n_user, $n_domain) = $new_acct =~ m/^(\S+?)\@(\S+)/ if $new_acct;

    my $userdir = get_home_directory( $user, $domain );

#     my $XY = substr($user, 0, 2);	# Get the first 2 chars of $user
#     my $newXY = substr($n_user, 0, 2) if $n_user;	# Get the first 2 chars of $n_user

    my $sql = '';

    if ($name)
    {
	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set $cfg{courier_mysql}{NAME_FIELD} = ".$cdb->quote($name);
	$sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account).";";
	$cdb->do($sql) or warn "Can't change name: ".$cdb->errstr()."\n";
    }

    if ($password)
    {
	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set";
	$sql .= " $cfg{courier_mysql}{CRYPT_PWFIELD} = ".$cdb->quote(crypt($password, $password)) if $cfg{courier_mysql}{CRYPT_PWFIELD};
	$sql .= "," if ($cfg{courier_mysql}{CRYPT_PWFIELD} and $cfg{courier_mysql}{CLEAR_PWFIELD});
	$sql .= " $cfg{courier_mysql}{CLEAR_PWFIELD} = ".$cdb->quote($password) if $cfg{courier_mysql}{CLEAR_PWFIELD};
	$sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account).";";
	$cdb->do($sql) or warn "Can't change password: ".$cdb->errstr()."\n";
    }

    if ($new_acct)
    {
	my $nuserdir = get_home_directory( $n_user, $n_domain );  
	die "Can't rename account: User exists\n" if (-e "$nuserdir");

	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($new_acct);
	$sql .= " , $cfg{courier_mysql}{HOME_FIELD} = ".$cdb->quote("$nuserdir");
	$sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account).";";
	$cdb->do($sql) or die "Can't change account name: ".$cdb->errstr()."\n";

	# We need to change the aliases as well.
	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set $cfg{courier_mysql}{ALIAS_FIELD} = ".$cdb->quote($new_acct);
	$sql .= " where $cfg{courier_mysql}{ALIAS_FIELD} = ".$cdb->quote($account).";";
	$cdb->do($sql) or die "Can't update aliases to reflect account name change: ".$cdb->errstr()."\n";

	mkdir_p( "$nuserdir",  		 
		 0775,  		 
		 (getpwnam($cfg{courier}{courier_user}))[2],  		
		 (getgrnam($cfg{courier}{courier_group}))[2] )
  	    || die "could not create user directory: $nuserdir";    

	system ('mv', "$userdir", "$nuserdir");

	# We'll need to update the SpamAssassin preferences as well.
	if ($cfg{spamassassin}{use_sa})
	{
	    # Note: table names are hardcoded into SA and are not (easily) configurable.
	    $sql = "UPDATE $cfg{spamassassin}{sql_table} set username = ".$sadb->quote($new_acct);
	    $sql .= " where username = ".$sadb->quote($account);
	    $sadb->do($sql) or die "Can't update SpamAssassin preferences: ".$sadb->errstr()."\n";
	}

	# ... and SM address book
	if ($cfg{sm}{use_sm_address})
	{
	    # Note: The column names are hardcoded and not easy to change.
	    my $sql = "UPDATE $cfg{sm}{address_table} set owner = ".$sm_addr_db->quote($new_acct);
	    $sql .= " where owner = ".$sm_addr_db->quote($account);
	    $sm_addr_db->do($sql) or die "Can't update SquirrelMail address book: ".$sm_addr_db->errstr()."\n";
	}

	# ... and SM prefs
	if ($cfg{sm}{use_sm_userpref})
	{
	    my $sql = "UPDATE $cfg{sm}{userpref_table} set $cfg{sm}{userpref_user_field} = ".$sm_pref_db->quote($new_acct);
	    $sql .= " where $cfg{sm}{userpref_user_field} = ".$sm_pref_db->quote($account);
	    $sm_pref_db->do($sql) or die "Can't update SquirrelMail preferences: ".$sm_pref_db->errstr()."\n";
	}
    }
}

sub show
{
    my ($account, @params) = @_;

    my $sql = "SELECT * from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} LIKE ".$cdb->quote($account).";";
    my $sth = $cdb->prepare($sql) or die "Can't access DB: ".$cdb->errstr()."\n";
    $sth->execute() or die "Can't access DB: ".$sth->errstr()."\n";
    while (my $acct = $sth->fetchrow_hashref())
    {
	print "$acct->{$cfg{courier_mysql}{LOGIN_FIELD}}";
	print ":$acct->{$cfg{courier_mysql}{CRYPT_PWFIELD}}" if $cfg{courier_mysql}{CRYPT_PWFIELD};
	print ":$acct->{$cfg{courier_mysql}{CLEAR_PWFIELD}}" if $cfg{courier_mysql}{CLEAR_PWFIELD};
	print ":$acct->{$cfg{courier_mysql}{UID_FIELD}}";
	print ":$acct->{$cfg{courier_mysql}{GID_FIELD}}";
	print ":$acct->{$cfg{courier_mysql}{NAME_FIELD}}";
	print ":$acct->{$cfg{courier_mysql}{HOME_FIELD}}";
	print ":$acct->{$cfg{courier_mysql}{MAILDIR_FIELD}}" if $cfg{courier_mysql}{MAILDIR_FIELD};
	print ":$acct->{$cfg{courier_mysql}{QUOTA_FIELD}}" if $cfg{courier_mysql}{QUOTA_FIELD};
	print "\n";
    }
    $sth->finish();
}

sub alias
{
    my ($alias_cmd, @params) = @_;

    if    ($alias_cmd eq 'add')	{ alias_add (@params); }
    elsif ($alias_cmd eq 'del') { alias_del (@params); }
    elsif ($alias_cmd eq 'mod') { alias_mod (@params); }
    elsif ($alias_cmd eq 'show'){ alias_show(@params); }
    else			{ alias_help(@params); }
}

sub alias_add
{
    my ($account, $alias, @params) = @_;
    if (not defined $account or not defined $alias)
    {
	alias_help();
	exit;
    }
    my $name = '';
    my $password = '';
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-n')	{ $name = $params[$i+1]; }
	elsif ($params[$i] eq '-p')	{ $password = $params[$i+1]; }
    }
    # Get account info.
    my $sql = "SELECT * from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account).";";
    my $sth = $cdb->prepare($sql) or die "Can't access DB: ".$cdb->errstr()."\n";
    $sth->execute() or die "Can't access DB: ".$cdb->errstr()."\n";
    my $acct = $sth->fetchrow_hashref();
    die "Unknown account $account.\n" if (ref $acct ne 'HASH');

    $name = $acct->{$cfg{courier_mysql}{NAME_FIELD}} unless $name;

    $sql = "INSERT into $cfg{courier_mysql}{USER_TABLE} set ";
    $sql .= " $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($alias);
    $sql .= ", $cfg{courier_mysql}{UID_FIELD} = ". $cdb->quote((getpwnam($cfg{courier}{courier_user}))[2]);
    $sql .= ", $cfg{courier_mysql}{GID_FIELD} = ".$cdb->quote((getgrnam($cfg{courier}{courier_group}))[2]);
    if ($password)
    {
	$sql .= ", $cfg{courier_mysql}{CRYPT_PWFIELD} = ".$cdb->quote(crypt($password, $password)) if $cfg{courier_mysql}{CRYPT_PWFIELD};
	$sql .= ", $cfg{courier_mysql}{CLEAR_PWFIELD} = ".$cdb->quote($password) if $cfg{courier_mysql}{CLEAR_PWFIELD};
    }
    else
    {
	$sql .= ", $cfg{courier_mysql}{CRYPT_PWFIELD} = ".$cdb->quote($acct->{$cfg{courier_mysql}{CRYPT_PWFIELD}}) if $cfg{courier_mysql}{CRYPT_PWFIELD};
	$sql .= ", $cfg{courier_mysql}{CLEAR_PWFIELD} = ".$cdb->quote($acct->{$cfg{courier_mysql}{CLEAR_PWFIELD}}) if $cfg{courier_mysql}{CLEAR_PWFIELD};
    }
    $sql .= ", $cfg{courier_mysql}{HOME_FIELD} = ".$cdb->quote($acct->{$cfg{courier_mysql}{HOME_FIELD}});
    $sql .= ", $cfg{courier_mysql}{NAME_FIELD} = ".$cdb->quote($name);
    $sql .= ", $cfg{courier_mysql}{QUOTA_FIELD} = ".$cdb->quote($acct->{$cfg{courier_mysql}{QUOTA_FIELD}});
    $sql .= ", $cfg{courier_mysql}{ALIAS_FIELD} = ".$cdb->quote($account);
    $sql .= ";";

    $cdb->do($sql) or die "Can't add account: ".$cdb->errstr()."\n";
}

sub alias_del
{
    my ($account, $alias, @params) = @_;
    if (not defined $account)
    {
	alias_help();
	exit;
    }

    $alias = '%' unless $alias;

    my $sql = "DELETE from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} LIKE ".$cdb->quote($alias);
    $sql .= " and $cfg{courier_mysql}{ALIAS_FIELD} = ".$cdb->quote($account).";";
    $cdb->do($sql) or die "Can't delete alias(es) for account: ".$cdb->errstr()."\n";

    # Remove alias settings in SpamAssassin if it's being used.
    if ($cfg{spamassassin}{use_sa})
    {
	$sql = "DELETE from $cfg{spamassassin}{sql_table} where username = ".$sadb->quote($alias).";";
	$sadb->do($sql) or die "Can't delete alias SpamAssassin preferences: ".$sadb->errstr()."\n";
    }
}

sub alias_mod
{
    my ($account, $alias, @params) = @_;
    if (not defined $account or not defined $alias)
    {
	alias_help();
	exit;
    }

    my $name = '';
    my $password = '';
    my $new_alias = '';
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-n')	{ $name = $params[$i+1]; }
	elsif ($params[$i] eq '-p')	{ $password = $params[$i+1]; }
	elsif ($params[$i] eq '-a')	{ $new_alias = $params[$i+1]; }
    }

    # Get account info.
    my $sql = "SELECT * from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account).";";
    my $sth = $cdb->prepare($sql) or die "Can't access DB: ".$cdb->errstr()."\n";
    $sth->execute() or die "Can't access DB: ".$cdb->errstr()."\n";
    my $acct = $sth->fetchrow_hashref();
    die "Unknown account $account.\n" if (ref $acct ne 'HASH');

    $name = $acct->{$cfg{courier_mysql}{NAME_FIELD}} unless $name;
    $password = generate_password(10) unless $password;

    $sql = '';

    if ($name)
    {
	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set $cfg{courier_mysql}{NAME_FIELD} = ".$cdb->quote($name);
	$sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($alias).";";
	$cdb->do($sql) or warn "Can't change name: ".$cdb->errstr()."\n";
    }

    if ($password)
    {
	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set";
	$sql .= " $cfg{courier_mysql}{CRYPT_PWFIELD} = ".$cdb->quote(crypt($password, $password)) if $cfg{courier_mysql}{CRYPT_PWFIELD};
	$sql .= "," if ($cfg{courier_mysql}{CRYPT_PWFIELD} and $cfg{courier_mysql}{CLEAR_PWFIELD});
	$sql .= " $cfg{courier_mysql}{CLEAR_PWFIELD} = ".$cdb->quote($password) if $cfg{courier_mysql}{CLEAR_PWFIELD};
	$sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($alias).";";
	$cdb->do($sql) or warn "Can't change password: ".$cdb->errstr()."\n";
    }
    
    if ($new_alias)
    {
	$sql = "UPDATE $cfg{courier_mysql}{USER_TABLE} set ";
	$sql .= " $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($new_alias);
	$sql .= " where $cfg{courier_mysql}{ALIAS_FIELD} = ".$cdb->quote($account);
	$sql .= " and $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($alias);
	$sql .= ";";

	$cdb->do($sql) or die "Can't add account: ".$cdb->errstr()."\n";

	# We need to update the SpamAssassin table if the alias has changed
	if ($new_alias and $cfg{spamassassin}{use_sa})
	{
	    $sql = "UPDATE $cfg{spamassassin}{sql_table} set username = ".$sadb->quote($new_alias);
	    $sql .= " where username = ".$sadb->quote($alias);
	    $sadb->do($sql) or die "Can't update SpamAssassin preferences: ".$sadb->errstr()."\n";
	}
    }
}

sub alias_show
{
    my ($account, $alias, @params) = @_;
    if (not defined $account)
    {
	alias_help();
	exit;
    }

    $alias = '%' if not $alias;

    my $sql = "SELECT * from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} LIKE ".$cdb->quote($alias);
    $sql .= " and $cfg{courier_mysql}{ALIAS_FIELD} = ".$cdb->quote($account).";";
    my $sth = $cdb->prepare($sql) or die "Can't access DB: ".$cdb->errstr()."\n";
    $sth->execute() or die "Can't access DB: ".$sth->errstr()."\n";
    while (my $alias = $sth->fetchrow_hashref())
    {
	print "$alias->{$cfg{courier_mysql}{LOGIN_FIELD}}";
	print ":$alias->{$cfg{courier_mysql}{CRYPT_PWFIELD}}" if $cfg{courier_mysql}{CRYPT_PWFIELD};
	print ":$alias->{$cfg{courier_mysql}{CLEAR_PWFIELD}}" if $cfg{courier_mysql}{CLEAR_PWFIELD};
	print ":$alias->{$cfg{courier_mysql}{UID_FIELD}}";
	print ":$alias->{$cfg{courier_mysql}{GID_FIELD}}";
	print ":$alias->{$cfg{courier_mysql}{NAME_FIELD}}";
	print ":$alias->{$cfg{courier_mysql}{HOME_FIELD}}";
	print ":$alias->{$cfg{courier_mysql}{MAILDIR_FIELD}}" if $cfg{courier_mysql}{MAILDIR_FIELD};
	print ":$alias->{$cfg{courier_mysql}{QUOTA_FIELD}}" if $cfg{courier_mysql}{QUOTA_FIELD};
	print "\n";
    }
    $sth->finish();
}

sub alias_help { help(); }

sub domain
{
    my ($domain_cmd, @params) = @_;

    if    ($domain_cmd eq 'add') { domain_add (@params); }
    elsif ($domain_cmd eq 'del') { domain_del (@params); }
    elsif ($domain_cmd eq 'mod') { domain_mod (@params); }
    elsif ($domain_cmd eq 'show'){ domain_show(@params); }
    else			 { domain_help(@params); }
}

sub domain_add
{
    my ($domain, @params) = @_;
    if (not defined $domain)
    {
	domain_help();
	exit();
    }

    $domain = lc($domain);

    for (my $i = 0; $i < @params; $i++)
    {
	# No params
    }

    my $domaindir = get_domain_directory( $domain );

    if (-d "$domaindir")
    {
	die "Can't add $domain: $domaindir already  exists\n";
    }
    else
    {
	mkdir_p ("$domaindir", 
		 0775,  	
		 (getpwnam($cfg{courier}{courier_user}))[2],  		
		 (getgrnam($cfg{courier}{courier_group}))[2] )
   	    || die "could not create domain directory: $domaindir";    
    }
    
    add_line_to_file ($hosteddomains, $domain);
    add_line_to_file ($esmtpacceptmailfor, $domain);
    add_line_fo_file ($logindomainlist, $domain) if (-e "$logindomainlist");

    system($makehosteddomains);
    system($makeacceptmailfor);
    system($courier_rc, 'restart');
}

sub domain_del
{
    my ($domain, @params) = @_;
    if (not defined $domain)
    {
	domain_help();
	exit();
    }

    $domain = lc($domain);

    # Watch out for '..' in the domain name
    die "Can't delete domain: Bad domiain name '$domain'.\n" if $domain =~/\.\./;

    # Clean domain out of hostedomainlist and logindomainslist
    del_line_from_file($hosteddomains, $domain);
    del_line_from_file($esmtpacceptmailfor, $domain);
    del_line_from_file($logindomainlist, $domain) if -e $logindomainlist;

    system ($makehosteddomains);
    system ($makeacceptmailfor);
    system ($courier_rc, 'restart');

    my $recursive = 0;
    for (my $i = 0; $i < @params; $i++)
    {
	if ($params[$i] eq '-r')	{ $recursive = 1; }
    }

    open (VUSER, "$0 show \"\@$domain\"|") or die "Can't get user list: $!\n";
    my $hasaccts = 0;
    while (<VUSER>)
    {
	$hasaccts = 1;
	my ($acct, @junk) = split(':');
	if ($recursive)
	{
	    del($acct);
	}
	else
	{
	    last;
	}
    }
    close VUSER;

    if (not $recursive and $hasaccts)
    {
	die "Can't delete domain: Domain not empty.\n";
    }

    # It should now be safe to delete the domain directory.
    my $domaindir = get_domain_directory( $domain );
    system ('rm', '-r', "$domaindir");
}

sub domain_mod
{
    my ($domain, @params) = @_;

    if (not defined $domain)
    {
	domain_help();
	exit();
    }

    $domain = lc($domain);

    # Watch out for '..' in the domain name
    die "Can't delete domain: Bad domiain name '$domain'.\n" if $domain =~/\.\./;

    my $new_domain = '';
    my $recurse = 0;
    for (my $i = 0; $i < @params; $i++)
    {
	if ($params[$i] eq '-d')	{ $new_domain = $params[$i+1]; }
	elsif ($params[$i] eq '-r')	{ $recurse = 1; }
    }

    if ($new_domain)
    {
	$new_domain = lc($new_domain);
	my $domaindir = get_domain_directory( $new_domain );
	if (-d "$domaindir")
	{
	    die "Can't rename domain to $new_domain: Domain directory ($domaindir) exists.\n";
	}

	repl_line_in_file ($hosteddomains, $domain, $new_domain);
	repl_line_in_file ($esmtpacceptmailfor, $domain, $new_domain);
	repl_line_in_file ($logindomainlist, $domain, $new_domain) if -e $logindomainlist;

	system ($makehosteddomains);
	system ($makeacceptmailfor);
	system ($courier_rc, 'restart');

	mkdir_p( $domaindir, 
		 0775,
		 (getpwnam($cfg{courier}{courier_user}))[2],  		
		 (getgrnam($cfg{courier}{courier_group}))[2] )
    	    || die "could not create domain directory: $domaindir";

	if ($recurse)
	{
	    my $sql = "SELECT $cfg{courier_mysql}{LOGIN_FIELD},$cfg{courier_mysql}{HOME_FIELD} from $cfg{courier_mysql}{USER_TABLE}";
	    $sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} LIKE ". $cdb->quote("%\@$domain");
	    $sql .= ";";
	    
	    my $sth = $cdb->prepare($sql) or die "Can't modify domain: Can't get user list: ".$cdb->errstr."\n";
	    $sth->execute() or die "Can't modify domain: Can't get user list: ".$sth->errstr."\n";
	    while (my ($acct, $home) = $sth->fetchrow_array())
	    {
		my $new_acct = $acct;
		$new_acct =~ s/\Q$domain\E$/$new_domain/e;
		mod($acct, '-a', $new_acct);	# Rename account.
	    }
	    $sth->finish;
	}

	# Ok, it's now safe to remove the old directory.
	system ('rm', '-r', "$domaindir");
    }
}

sub domain_show
{
    my ($domain, @params) = @_;
    $domain = lc($domain);

    my @domains = ();
    if ($domain)
    {
	@domains = ($domain);
    }
    else
    {
	open (HOSTED, $hosteddomains) or die "Can't open $hosteddomains: $!\n";
	@domains = <HOSTED>;
	close HOSTED;
	chomp @domains;
    }

    my $sql = "select count(*) from $cfg{courier_mysql}{USER_TABLE}";
    $sql .= " where $cfg{courier_mysql}{LOGIN_FIELD} LIKE ? and ISNULL($cfg{courier_mysql}{ALIAS_FIELD});";
    my $sth = $cdb->prepare($sql) or die "Can't prepare SQL: ".$cdb->errstr."\n";

    foreach my $dom (sort @domains)
    {
	print "$dom:";
	my $domaindir = get_domain_directory( $dom );

	print ((-d "$domaindir") ? "$domaindir" : "");
	print ":";

	$sth->execute("%\@$dom") or die "Can't get account count: ".$cdb->errstr."\n";
	my @count = $sth->fetchrow_array();
	$sth->finish;
	print "$count[0]\n";
    }
}

sub domain_help { help(); }

sub list
{
    die "Mailman is not enabled\n" unless $cfg{mailman}{use_mailman};

    my ($list_cmd, @params) = @_;

    if    ($list_cmd eq 'add')	{ list_add (@params); }
    elsif ($list_cmd eq 'del')	{ list_del (@params); }
    elsif ($list_cmd eq 'mod')	{ list_mod (@params); }
    else			{ list_help(@params); }
}

sub list_add
{
    my ($name, $account, $manager, @params) = @_;
    die "No name specified\n" if not $name;
    die "No account specified\n" if not $account;
    die "No manager specified\n" if not $manager;

    # Get other params.
    my $password = '';
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-p') { $password = $params[$i+1]; }
    }
    $password = generate_password(10) if (not $password);

    eval { add($account, '-p', $password, '-n', $name); };
    die "Can't create list: $@" if $@;

    # Get account's homedir so we can add files to it.
    my $sql = "SELECT $cfg{courier_mysql}{HOME_FIELD} from $cfg{courier_mysql}{USER_TABLE} where $cfg{courier_mysql}{LOGIN_FIELD} = ".$cdb->quote($account);
    my $sth = $cdb->prepare($sql) or die "Can't access DB: ".$cdb->errstr()."\n";
    $sth->execute or die "Can't access DB: ".$sth->errstr()."\n";
    if (my $acct = $sth->fetchrow_hashref())
    {
	my $homedir = $acct->{$cfg{courier_mysql}{HOME_DIR}};
	my @aliases = qw(admin bounces confirm join leave owner request subscribe unsubscribe);

	open (DOT_COURIER, ">$homedir/.courier") or die "Can't create alias file $homedir/.courier\n";
	print DOT_COURIER "|".$cfg{mm}{bin}."/mailman" ." post $name\n";
	close DOT_COURIER;
	chown_ug ($cfg{courier}{courier_user}, $cfg{courier}{courier_group}, "$homedir/.courier");

	foreach my $alias (@aliases)
	{
	    open (DOT_COURIER, ">$homedir/.courier-$alias") or die "Can't create alias file $homedir/.courier-alias\n";
	    print DOT_COURIER "|". $cfg{mailman}{bin}."/mailman". " $alias $name\n";
	    close DOT_COURIER;
	    chown_ug ($cfg{courier}{courier_user}, $cfg{courier}{courier_group}, "$homedir/.courier-$alias");
	}

    }
    else
    {
	# This should never, ever happen since we *just* created this
	# account above.
	die "Egad! $account doesn't exist even though it was just created.\n";
    }

    # Create the list.
    my @cmd = ($cfg{mm}{bin}."/newdir",
	       $name. ($cfg{mm}{domain}? "\@$cfg{mm}{domain}": ''),
	       $manager,
	       $password);
    my $rc = 0xffff & system (@cmd);
    $rc <<=8;
    if ($rc != 0)
    {
	del ($account);
	die "Can't add list $name: $!\n";
    }
}

sub list_del
{
    my ($name, $account, @params) = @_;
    die "No name specified\n" if not $name;
    die "No account specified\n" if not $account;

    # Get other params.
    my $recursive = 0;
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-r') { $recursive = 1; }
    }

    # Delete the list.
    my @cmd = ($cfg{mm}{bin}."/rmlist", $name);
    my $rc = 0xffff & system (@cmd);
    $rc <<=8;
    if ($rc != 0)
    {
	die "Can't add list $name: $!\n";
    }
    eval { del ($account); };
    die "Problem deleting list: $@" if $@;
}

sub list_mod
{
    my ($name, $account, @params) = @_;
    die "No name specified\n" if not $name;
    die "No account specified\n" if not $account;

    # Get other params.
    my $new_account = '';
    for (my $i = 0; $i < @params; $i++)
    {
	if    ($params[$i] eq '-a') { $new_account = $params[$i+1]; }
    }

    if ($new_account)
    {
	eval { mod ($account, '-a', $new_account); };
	die "Can't modify list address: $@" if $@;
    }
}

sub list_help { help(@_); }

sub chown_ug
{
    my ($user, $group, @files) = @_;
    my $uid = (getpwnam($user))[2];	# Get the numerical user ID
    my $gid = (getgrnam($group))[2];	# Get the numerical group ID
    return chown $uid, $gid, @files;
}

sub help
{
    system("pod2usage", $0);
}

sub generate_password
{
    my $len = shift || 10;
    my @valid = (0..9, 'a'..'z', 'A'..'Z', '@', '#', '%', '^', '*');
    my $password = '';
    for (1 .. $len)
    {
	$password .= $valid[int (rand $#valid)];
    }
    return $password;
}

sub mkdir_p
{
    my ($dir, $mode, $uid, $gid) = @_;
    $dir =~ s/\/$//;

    if( -e "$dir" )
    {
	return 1;
    }

    my $parent = $dir;
    $parent =~ s/\/[^\/]*$//;

    if( !$parent ) { return 0; }
    else 
    { 
	return mkdir_p( $parent, $mode, $uid, $gid ) 
	    && mkdir( $dir ) 
	    && chown( $uid, $gid, $dir );
    }
}



sub add_line_to_file
{
    my ($file, $line) = @_[0,1];

    open (FILE, ">>$file") or die "Can't open $file: $!\n";
    print FILE "$line\n";
    close FILE;
}

sub del_line_from_file
{
    my ($file, $line) = @_[0,1];

    while (-e "$file.tmp") { sleep(rand(int 3)); }

    open (FILE, $file) or die "Can't open $file: $!\n";
    open (TMP, ">$file.tmp") or die "Can't open $file.tmp: $!\n";
    while (<FILE>)
    {
	chomp;
	print TMP "$_\n" unless /^\Q$line\E$/;
    }
    close FILE;
    close TMP;

    rename ("$file.tmp", $file) or die "Can't rename $file.tmp to $file: $!\n";
}

sub repl_line_in_file
{
    my ($file, $oline, $nline) = @_[0..2];

    while (-e "$file.tmp") { sleep(rand(int 3)); }

    open (FILE, $file) or die "Can't open $file: $!\n";
    open (TMP, ">$file.tmp") or die "Can't open $file.tmp: $!\n";
    while (<FILE>)
    {
	chomp;
	if (/^\Q$oline\E$/)
	{
	    print TMP "$nline\n";
	}
	else
	{
	    print TMP "$_\n";
	}
	
    }
    close FILE;
    close TMP;

    rename "$file.tmp", $file or die "Can't rename $file.tmp to $file: $!\n";
}


__END__

=head1 NAME

vuser - Adds/Removes/Modifies MySQL virtual users for Courier

=head1 SYNOPSIS

 vuser [options] add account [-n name] [-p password]
 vuser [options] del account
 vuser [options] mod account [-n name] [-p password] [-a new_account]
 vuser [options] show account

 vuser [options] alias add account alias [-n name] [-p password]
 vuser [options] alias del account [alias]
 vuser [options] alias mod account alias [-n name] [-p password] [-a new_alias]
 vuser [options] alias show account

 vuser [options] domain add domain
 vuser [options] domain del domain [-r]
 vuser [options] domain mod domain [-d new_domain]
 vuser [options] domain show domain

 vuser [options] list add name account manager [-p password]
 vuser [options] list del name account [-r]
 vuser [options] list mod name account [-a new_account]

 vuser help

 options:

 -e /path/to/vuser.conf
 	use the vuser.conf file specified.  If this option isn't specified, 
	vuser.conf will be loaded from one of the default locations:
		/etc/vuser.conf
		/usr/local/etc/vuser.conf

	

=head1 DESCRIPTION

B<vuser> handles virtual accounts for courier and has limited support
for SpamAssassin and SquirrelMail.

In all cases, I<account> is the name of the account to operate on.

=head2 options

=over 4

=item config|f

The location of the configuration file. If omitted, vuser will look for
vuser.conf in some standard places.

=back

=head2 add

B<Options:>

=over 4

=item -n name

The real name for this user. Ex: "John Doe"

=item -p password

If provided, then the account's password is set to I<password>.
Otherwise, the account is assigned a random password.

=back

=head2 del

Delete account

=head2 mod

B<Options:>

=over 4

=item -n name

The real name for this user. Ex: "John Doe"

=item -p password

If provided, then the account's password is set to I<password>.
Otherwise, the password is not changed.

=item -a new_account

Change the account name to I<new_account>.

=back

=head2 show

Show account information. I<account> may contain SQL wildcards.

=head2 help

Display help message.

=head2 alias add

TODO

=head2 alias del

TODO

=head2 alias mod

TODO

=head2 alias show

TODO

=head2 alias help

TODO

=head2 domain add

TODO

=head2 domain del

B<Note:> Speecifying C<-r> will delete I<all> accounts in this domain.
You have been warned.

=head2 domain mod

TODO

=head2 domain show

TODO

=head2 domain help

TODO

=head1 FILES

=over 4

=item /usr/local/etc/courier/authmysqlrc

Courier's authmysql config file.

=item /usr/local/etc/courier/virtual/hosteddomains

See L<courier(8)>.

=item /usr/local/etc/courier/virtual/logindomainlist

See L<courier(8)>.

=item /etc/mail/spamassassin/local.cf

SpamAssassin config file.

=back

=head1 BUGS

There is no way to prompt the user for a password for the
account and passwords are passed in from the command line. It
is possible that someone may be able to see the password if they
run B<ps> at the right time.

It's possible (even likely) that B<vuser> will connect to the same
database twice when SpamAssassin is being used. This is because, in
theory, the SpamAssassin DB can be on a seperate system. If it's on
the same system, you get two connections. This is particularly true
if you are using SquirrelMail too.

I should be more careful when parsing the SquirrelMail config file.

=head1 AUTHOR

Randy Smith <randys@amigo.net>

=head1 COPYRIGHT

 Copyright (c) 2002 Randy Smith
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

=cut
